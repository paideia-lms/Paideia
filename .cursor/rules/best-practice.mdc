---
description:
globs:
alwaysApply: true
---

## frontend

Should use mantine component all the time. we should use design token from mantine. 

We should not use tailwind classes. Strictly prohibited.

We should not use any external css framework. Strictly prohibited.

when working with jsx array, we should not use index as key. we should use the id of the item if available.

we should use `<meta>` in the page component.

use `matches` to from Route.ComponentProps to check current route.

don't use `useEffect`, use `useEffectEvent` instead.

in loader and actions, we need to use `overrideAccess` to false and provide the current user ( `effectiveUser ?? authenticatedUser`) to the function.

we don't check for access in loader and actions. we only check for access in internal functions and through access hook in collections. 

## contexts 

react router context should import types from payload types. It should create types for itself to provide type stability for the frontend.

## testing 

every features on the backend should be tested using `bun:test`.

we should only use payload local api. we should not use anything related to nextjs.

testing should be simple and easy to read. for complex test, we better just skip and and test manually instead.

each test files should only have one describe block. each test file related to database, s3, redis or payload should have do a refresh using beforeAll. 

if you really want a completely isolated test, you should always create a new root describe block and its own beforeAll and AfterAll

## error handling

we **should not** use try catch, especially not in internal functions which we use typescript result, it will be confusing and hard to manage. we should use typescript result to handle the error, using `Result.wrap`. When a function return a result, function should be named with `try` prefix like `tryFunction` or `trySomething`.

in the loader of react router, we should throw ErrorResponse rather than just error. 

when throwing error using typescript result, we should first create the error in `app/utils/error.ts` first. The error class should be used in the `transformError` in `Result.wrap` or `Result.try`.

## Database 

when an operation is doing multiple mutation to the database, we should **always** use transaction.

database migration should always be non breaking and backward compatible.

payload local api return document with unknown depth. we should handle both case when depth is 0 and 1, value is either object or id (string). 

**strictly avoid** using `as` operator in internal functions. **No type casting allowed**.

use virtual field over depth. we would rather have a nested virtual field than have depth more than 2, because depth can cause infinite loop.

all globals collections should be defined in a single `server/collections/globals.ts`.

## internal functions 

when user id provided to the internal function, we can always assume the user exists.

we should not expose the depth variable to args for internal functions. The output type should be defined.


## Changelog

changelog should be written in the `changelogs` folder. each changelog should be named like `0001-2025-01-01-feature-or-change-name.md`. the number should be the order of the changelog. the date should be the date of the changelog. the feature name should be the name of the feature.